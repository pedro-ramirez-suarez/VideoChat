{"name":"Videochat","tagline":"A video chat with HTML5 + javascript + Server Sent Events","body":"<p>I like to play with technology, push it and use it on not very common scenarios, this project is just that, some technology(SSE) being used for something(Video Conference) that is better acomplished with another technoligy, in this case WebRTC.</p>\r\n![demo](https://raw.githubusercontent.com/pedro-ramirez-suarez/VideoChat/gh-pages/images/videochat.png)\r\n<p>There are many things that can be done better, but the purpose of this project, is not to have a perfect piece of code, but to have a working proof of concept.</p>\r\n\r\n<h2>Why Server Sent Events?</h2>\r\n<p>Compared with WebSockets, Server Sent Events apps are very easy to build with Asp.Net MVC, and with the help of <a href=\"https://github.com/pedro-ramirez-suarez/needletailtools/wiki/Using-Needletail.Mvc\" target=\"_blank\">Needletail.MVC</a> that helps you to build SSE apps without breaking your MVC pattern, it's even easier.</p>\r\n\r\n<p>The main limitations of using SSE for this kind of application are:</p>\r\n- SSE is not peer to peer, neither bi-directional, nor full duplex, so it's slower.\r\n- The ammount of data received and sent is bigger with SSE, to upload data to the server, you need to send it as a file, or as a string, if you send strings you need to be sure that those are Base64(which increase the size) otherwise the server may reject the request, also, when sending data to the client, you can only serve files or strings, as incomming connections, you need to convert those strings to Base64 or the server may not send the info that you want.\r\n- Trial and error is the way you sicronize the image and audio.\r\n\r\nThe application supports only two users, but with minor changes it may support many more.\r\n\r\nIt uses  the following open source projects:\r\n- Bootstap\r\n- JQuery\r\n- Recorderjs\r\n- libmp3lame-js\r\n \r\nI modified the Recorderjs library to record mono audio instead of stereo and also to automatically convert the wav file to mp3 file using libmp3lame-js.\r\n\r\n<b>Important </b> SSE is not supported on Internet Explorer(any version), also, sometimes  SSE does not work fine on IIS Express.\r\n\r\n<h2>Points of interest</h2>\r\n<p>The code in the server that receives the sequence of images and the audio and sends it to the other user is very simple:</p>\r\n<pre><code>\r\n        [HttpPost]\r\n        public JsonResult PushVideoFragment()\r\n        {\r\n            //Get the audio stream and store it on a local collection\r\n            MemoryStream ms = new MemoryStream();\r\n            Request.Files[0].InputStream.CopyTo(ms);\r\n            ms.Position = 0;\r\n            string id = Guid.NewGuid().ToString().Replace(\"-\", \"\");\r\n            audios.Add(id, ms);\r\n            //store the images locally\r\n            var frames = new List<string>();\r\n            foreach (string k in Request.Form.Keys)\r\n            {\r\n                frames.Add(Request.Form[k]);\r\n            }\r\n\r\n            //send the audio to everyone but me\r\n            var receivers = RemoteController.Users.Where(u => u != Request.Cookies[\"videoChatUser\"].Value);\r\n            foreach (var u in receivers)\r\n            {\r\n                dynamic call = new ClientCall { CallerId = Request.Cookies[\"videoChatUser\"].Value, ClientId = u };\r\n                //since we cannot send the audio, we just send the ID of the audio that we just received\r\n                call.updateVideoFragment(id, frames, Request.Cookies[\"videoChatUser\"].Value);\r\n                RemoteExecution.ExecuteOnClient(call, false);\r\n            }\r\n            return Json(new { success = true });\r\n        }\r\n\r\n</code></pre>\r\n\r\n<p>The most important pieces of code are in the Javascript code</p>\r\n<pre><code>//Send all the data to the server after the audio is converted\r\nfunction sendAudioAndVideo() {\r\n    var formData = new FormData();\r\n    //set the frames\r\n    for (var x in frames) {\r\n        //only process first 10 frames, this is to sync video and audio\r\n        if (x > 9)\r\n            break;\r\n        //append a new frame\r\n        formData.append('frame' + x, frames[x]);\r\n    }\r\n    //clear the frames\r\n    frames = [];\r\n    //set the audio\r\n    formData.append('edition[audio]', currentAudio);\r\n    //Send the audio to the server as a file attachment\r\n    $.ajax({\r\n        type: 'POST',\r\n        url: pushVideoFragmentUrl,\r\n        data: formData,\r\n        contentType: false,\r\n        cache: false,\r\n        processData: false,\r\n    });\r\n}\r\n\r\n//This function is \"invoked\" from the MVC HomeController\r\nfunction updateVideoFragment(id, remoteFrames, user) {\r\n    //update frames\r\n    for (var x in remoteFrames) {\r\n        if (remoteFrames[x].length == 0)\r\n            continue;\r\n        pendingFrames.push(remoteFrames[x]);\r\n    }\r\n\r\n    //set the user who send the video\r\n    $('#remoteUser').html(user);\r\n    //we are not allowed to send the audio file directly, so we just set the src of the stream\r\n    //play new audio\r\n    $(\"#audio\").attr(\"src\", updateAudioUrl + '/' + id);\r\n    $(\"#audio\")[0].play();\r\n}</code></pre>\r\n\r\n\r\n<h4>Since only one browser(or tab) is allowed to access the camera and microphone, you need to use two computers to test the application</h4>\r\n\r\n<b>Enjoy!</b>","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}